<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>手写系统函数</title>
      <link href="/blog/2022/03/03/handwriting/"/>
      <url>/blog/2022/03/03/handwriting/</url>
      
        <content type="html"><![CDATA[<h1 id="对系统的一些函数手写"><a href="#对系统的一些函数手写" class="headerlink" title="对系统的一些函数手写"></a>对系统的一些函数手写</h1><h3 id="今天学习了手写-call-函数，下面呈现出来"><a href="#今天学习了手写-call-函数，下面呈现出来" class="headerlink" title="今天学习了手写 call 函数，下面呈现出来"></a>今天学习了手写 call 函数，下面呈现出来</h3><blockquote><p>call 函数主要用来修改 this 的指向，下面来手写出来</p></blockquote><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token function-variable function">getName</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> person1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  name<span class="token operator">:</span> <span class="token string">'张三'</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token comment">// 手写call函数</span><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myCall</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 判断是否是个函数调用的，也可以删掉</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 判断是否传了新的this,如果没穿this定为window</span>  context <span class="token operator">=</span> context <span class="token operator">||</span> window  <span class="token comment">// 将当前函数给到context的fn</span>  context<span class="token punctuation">.</span>fn <span class="token operator">=</span> <span class="token keyword">this</span>  <span class="token keyword">const</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arguments<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment">// 调用函数，本demo没有剩余参数</span>  <span class="token keyword">const</span> result <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span>  <span class="token keyword">return</span> result<span class="token punctuation">&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>getName<span class="token punctuation">.</span><span class="token function">myCall</span><span class="token punctuation">(</span>person1<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于接口的一些问题</title>
      <link href="/blog/2022/01/18/interface/"/>
      <url>/blog/2022/01/18/interface/</url>
      
        <content type="html"><![CDATA[<h3 id="后端返回数据直接渲染时，遇到了如下问题"><a href="#后端返回数据直接渲染时，遇到了如下问题" class="headerlink" title="后端返回数据直接渲染时，遇到了如下问题"></a>后端返回数据直接渲染时，遇到了如下问题</h3><blockquote><p>数据需要循环渲染，而且返回的是一个对象</p></blockquote><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">// 这是后台返回的数据</span><span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">&#123;</span> type<span class="token operator">:</span> <span class="token string">'TEXT'</span><span class="token punctuation">,</span> key<span class="token operator">:</span> <span class="token string">'222222'</span><span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token string">'213123'</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="那么要怎么循环呢？"><a href="#那么要怎么循环呢？" class="headerlink" title="那么要怎么循环呢？"></a>那么要怎么循环呢？</h4><blockquote><p>经过思考发现了如下方法</p></blockquote><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> keyList <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="具体渲染方法如下"><a href="#具体渲染方法如下" class="headerlink" title="具体渲染方法如下"></a>具体渲染方法如下</h4><ul><li>循环的数组为 keyList</li><li>展示的 key 直接用 item 显示</li><li>展示的 value 需要用 res[item] 的方式显示</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue中关于图片的一些问题</title>
      <link href="/blog/2021/12/28/imgpath/"/>
      <url>/blog/2021/12/28/imgpath/</url>
      
        <content type="html"><![CDATA[<h3 id="关于-Vue-中循环生成图片方法"><a href="#关于-Vue-中循环生成图片方法" class="headerlink" title="关于 Vue 中循环生成图片方法"></a>关于 Vue 中循环生成图片方法</h3><h5 id="先上基础"><a href="#先上基础" class="headerlink" title="先上基础"></a>先上基础</h5><ul><li>在 Vue 中 img 图片的 src 的路径有两种索引方法：<ol><li>可以直接 <code>&lt;img src=&quot;路径&quot; alt=&quot;一张图片&quot;&gt;</code></li><li>在 data 中 imgSrc: require(‘图片路径’) 然后 <code>&lt;img :src=&quot;imgSrc&quot; alt=&quot;一张图片&quot;&gt;</code></li></ol></li></ul><h5 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h5><ul><li>那么如果想循环生成不同图片该怎么办？</li></ul><h5 id="思考一会儿。。。"><a href="#思考一会儿。。。" class="headerlink" title="思考一会儿。。。"></a>思考一会儿。。。</h5><ul><li>思考半天后</li></ul><h5 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h5><ul><li>可以通过生成对象的方式解决问题如下：<ol><li>在循环组件中定义如下结构<pre class="line-numbers language-js" data-language="js"><code class="language-js">imgSrc<span class="token operator">:</span> <span class="token punctuation">&#123;</span>    imgSrc1<span class="token operator">:</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'路径1'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    imgSrc2<span class="token operator">:</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'路径2'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    imgSrc3<span class="token operator">:</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'路径3'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    imgSrc4<span class="token operator">:</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'路径4'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    imgSrc5<span class="token operator">:</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'路径5'</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>循环时需要传递相对应的 变量名称(字符串类型)</li><li>循环结构写 <code>&lt;img :src=&quot;imgSrc[item.imgIndex]&quot; alt=&quot;一张图片&quot;&gt;</code></li></ol><ul><li>这里用到了比较基础的地方，imgSrc.imgSrc1 相当于 imgSrc[‘imgSrc1’]</li></ul></li></ul><h3 id="Vue-加载图片时-loading-效果"><a href="#Vue-加载图片时-loading-效果" class="headerlink" title="Vue 加载图片时 loading 效果"></a>Vue 加载图片时 loading 效果</h3><h5 id="就不多废话了直接上代码"><a href="#就不多废话了直接上代码" class="headerlink" title="就不多废话了直接上代码"></a>就不多废话了直接上代码</h5><pre class="line-numbers language-Vue" data-language="Vue"><code class="language-Vue">&lt;template&gt;  &lt;img :src&#x3D;&quot;loadingUrl&quot; alt&#x3D;&quot;一张图片&quot;&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      loadingUrl: require(&#39;loading路径&#39;),      imageUrl: require(&#39;要展示图片的地址&#39;),    &#125;  &#125;,  mounted() &#123;    const newImg &#x3D; new Image()    newImg.src &#x3D; this.imageUrl    newImg.onerror &#x3D; () &#x3D;&gt; &#123; &#x2F;&#x2F; 图片加载错误图片      newImg.src &#x3D; &#39;loading路径&#39;    &#125;    newImg.onload &#x3D; () &#x3D;&gt; &#123; &#x2F;&#x2F; 图片加载成功后      this.loadingUrl &#x3D; newImg.src    &#125;  &#125;&#125;&lt;&#x2F;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h6><ul><li>上面代码可以优化为一个组件，组件只需要介绍需要加载图片的路径。</li><li>可以在 img 写一个 ref 和一个默认的 class 这样方便控制 loading 图片的样式，也方便控制加载成功后图片的样式，可以在 onload 写 this.$refs.image.className = ‘成功后的名字’ 给 img 添加成功后的名字。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在React-hooks中使用Echarts</title>
      <link href="/blog/2021/09/19/echarts-in-react-hooks/"/>
      <url>/blog/2021/09/19/echarts-in-react-hooks/</url>
      
        <content type="html"><![CDATA[<h1 id="在-Hook-中使用-Echart"><a href="#在-Hook-中使用-Echart" class="headerlink" title="在 Hook 中使用 Echart"></a>在 Hook 中使用 Echart</h1><blockquote><p>在新版 Echart 也就是 5.X 中使用的时候在一次遇到了困难</p></blockquote><h3 id="使用方法（在艰辛的查阅资料后终于找到答案）"><a href="#使用方法（在艰辛的查阅资料后终于找到答案）" class="headerlink" title="使用方法（在艰辛的查阅资料后终于找到答案）"></a>使用方法（在艰辛的查阅资料后终于找到答案）</h3><ul><li>代码外壳</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> useEffect<span class="token punctuation">,</span> useRef <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">var</span> echarts <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'echarts'</span><span class="token punctuation">)</span><span class="token keyword">function</span> <span class="token function">MyChart</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> chartRef <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">let</span> myChart <span class="token operator">=</span> <span class="token keyword">null</span>  <span class="token keyword">const</span> option <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 表格配置以及数据</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">function</span> <span class="token function">renderChart</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> chart <span class="token operator">=</span> echarts<span class="token punctuation">.</span><span class="token function">getInstanceByDom</span><span class="token punctuation">(</span>chartRef<span class="token punctuation">.</span>current<span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>chart<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      myChart <span class="token operator">=</span> chart    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      myChart <span class="token operator">=</span> echarts<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span>chartRef<span class="token punctuation">.</span>current<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    myChart<span class="token punctuation">.</span><span class="token function">setOption</span><span class="token punctuation">(</span>option<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span>  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token function">renderChart</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      option <span class="token operator">&amp;&amp;</span> myChart<span class="token punctuation">.</span><span class="token function">setOption</span><span class="token punctuation">(</span>option<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    <span class="token operator">&lt;</span><span class="token operator">></span>      <span class="token operator">&lt;</span>div style<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> width<span class="token operator">:</span> <span class="token string">'800px'</span><span class="token punctuation">,</span> height<span class="token operator">:</span> <span class="token string">'800px'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> ref<span class="token operator">=</span><span class="token punctuation">&#123;</span>chartRef<span class="token punctuation">&#125;</span> <span class="token operator">/</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token operator">></span>  <span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">default</span> MyChart<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="改进方法（将代码分离出来，看起来清晰一些）"><a href="#改进方法（将代码分离出来，看起来清晰一些）" class="headerlink" title="改进方法（将代码分离出来，看起来清晰一些）"></a>改进方法（将代码分离出来，看起来清晰一些）</h3><ul><li>可以建立一个 useChart.js</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span> useEffect <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">var</span> echarts <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'echarts'</span><span class="token punctuation">)</span><span class="token keyword">function</span> <span class="token function">useChart</span><span class="token punctuation">(</span><span class="token parameter">chartRef<span class="token punctuation">,</span> options</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">let</span> myChart <span class="token operator">=</span> <span class="token keyword">null</span>  <span class="token keyword">function</span> <span class="token function">renderChart</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> chart <span class="token operator">=</span> echarts<span class="token punctuation">.</span><span class="token function">getInstanceByDom</span><span class="token punctuation">(</span>chartRef<span class="token punctuation">.</span>current<span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>chart<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      myChart <span class="token operator">=</span> chart    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      myChart <span class="token operator">=</span> echarts<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span>chartRef<span class="token punctuation">.</span>current<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    myChart<span class="token punctuation">.</span><span class="token function">setOption</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span>  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token function">renderChart</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>options<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>      myChart <span class="token operator">&amp;&amp;</span> myChart<span class="token punctuation">.</span><span class="token function">dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token keyword">return</span><span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">default</span> useChart<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>在使用 Echarts 文件中代码如下</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> useRef <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">import</span> useChart <span class="token keyword">from</span> <span class="token string">'./useChart'</span><span class="token keyword">function</span> <span class="token function">Chart</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">const</span> chartRef <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>  <span class="token keyword">const</span> option <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 表格配置以及数据</span>  <span class="token punctuation">&#125;</span>  <span class="token function">useChart</span><span class="token punctuation">(</span>chartRef<span class="token punctuation">,</span> option<span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>    <span class="token operator">&lt;</span><span class="token operator">></span>      <span class="token operator">&lt;</span>div style<span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> width<span class="token operator">:</span> <span class="token string">'400px'</span><span class="token punctuation">,</span> height<span class="token operator">:</span> <span class="token string">'400px'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> ref<span class="token operator">=</span><span class="token punctuation">&#123;</span>chartRef<span class="token punctuation">&#125;</span> <span class="token operator">/</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token operator">></span>  <span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">default</span> Chart<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Echarts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Echarts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有关 React-hook 的用法以及“坑”</title>
      <link href="/blog/2021/09/16/hooks/"/>
      <url>/blog/2021/09/16/hooks/</url>
      
        <content type="html"><![CDATA[<h1 id="React-hook"><a href="#React-hook" class="headerlink" title="React-hook"></a>React-hook</h1><blockquote><p>当下 React-hook 可以说非常热门，作为正牌小白还是有一些接收和不接受的，下面一 一列举。</p></blockquote><h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><ol><li>State Hook 让函数组件也可以有 state 状态, 并进行状态数据的读写操作</li><li>语法: const [xxx, setXxx] = React.useState(默认值)，在引入 React 的前提下 <code>import React from &#39;react&#39;</code></li><li>useState()说明:<ul><li>参数: 第一次初始化指定的值在内部作缓存</li><li>返回值: 包含2个元素的数组, 第1个为内部当前状态值, 第2个为更新状态值的函数</li></ul></li><li>setXxx()2种写法:<ul><li>setXxx(newValue): 参数为非函数值, 直接指定新的状态值, 内部用其覆盖原来的状态值</li><li>setXxx(value =&gt; newValue): 参数为函数, 接收原本的状态值, 返回新的状态值, 内部用其覆盖原来的状态值</li></ul></li><li>一个小水坑<ul><li>当想执行 setXxx 的回调的时候，因为 hook 中 setXxx 不支持第二个参数， 这时我们就需要配合 useEffect 通过监听 xxx 来执行 setXxx 的回调</li></ul></li></ol><h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><ol><li>Effect Hook 可以让你在函数组件中执行副作用操作(用于模拟类组件中的生命周期钩子)</li><li>React 中的副作用操作:<ul><li>发ajax请求数据获取</li><li>设置订阅 / 启动定时器</li><li>手动更改真实DOM</li></ul></li><li>语法和说明: <pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>         <span class="token comment">// 在此可以执行任何带副作用操作</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span> <span class="token comment">// 在组件卸载前执行</span>        <span class="token comment">// 在此做一些收尾工作, 比如清除定时器/取消订阅等</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>stateValue<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 如果指定的是[], 回调函数只会在第一次render()后执行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>可以把 useEffect Hook 看做如下三个函数的组合<ul><li>componentDidMount()</li><li>componentDidUpdate()</li><li>componentWillUnmount() </li></ul></li></ol><h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><ol><li>Ref Hook 可以在函数组件中存储/查找组件内的标签或任意其它数据</li><li>语法: const refContainer = useRef()</li><li>作用:保存标签对象,功能与 React.createRef() 一样</li></ol><h3 id="useHistory"><a href="#useHistory" class="headerlink" title="useHistory"></a>useHistory</h3><ol><li>useHistory Hook可以在函数组件中存储/查找组件内的标签或任意其它数据</li><li>语法: <pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> history <span class="token operator">=</span> <span class="token function">useHistory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>history<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'/home'</span><span class="token punctuation">)</span> <span class="token comment">// 可以是 replace('home') 或者 goBack() 等等</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>作用: 可以进行路由跳转，这里用起来就比 class 组件方便了</li></ol><h3 id="后续更新中。。。"><a href="#后续更新中。。。" class="headerlink" title="后续更新中。。。"></a>后续更新中。。。</h3>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AntD 表单无数据问题</title>
      <link href="/blog/2021/09/16/antd-form-item/"/>
      <url>/blog/2021/09/16/antd-form-item/</url>
      
        <content type="html"><![CDATA[<h1 id="提出问题（问题怎么那么多）"><a href="#提出问题（问题怎么那么多）" class="headerlink" title="提出问题（问题怎么那么多）"></a>提出问题（问题怎么那么多）</h1><blockquote><p>有时 form.item 的初始值和我们理想的不尽相同</p></blockquote><h3 id="真实场景"><a href="#真实场景" class="headerlink" title="真实场景"></a>真实场景</h3><ul><li>有时 form.item 绑定的数据的值需要从后台接口获取，这时 from.item 的 initialValue 就成了对应数据的初始值，可能是空串、数值0、空数组……</li><li>这时显示出来的数据就会是空串、数值0、空数组……</li></ul><h1 id="解决问题（查了很多资料后终于解决）"><a href="#解决问题（查了很多资料后终于解决）" class="headerlink" title="解决问题（查了很多资料后终于解决）"></a>解决问题（查了很多资料后终于解决）</h1><h3 id="设定场景"><a href="#设定场景" class="headerlink" title="设定场景"></a>设定场景</h3><ul><li>当在 react-hook 环境中，我们可以这样  <pre class="line-numbers language-js" data-language="js"><code class="language-js">React<span class="token punctuation">.</span><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    form<span class="token punctuation">.</span><span class="token function">resetFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>form<span class="token punctuation">.</span>item 的某个 value 绑定的变量<span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>通过监听变量值的变化，值发送改变后清除原来的值，把新的值重新渲染上去，就解决了。</li></ul>]]></content>
      
      
      <categories>
          
          <category> AntD </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AntD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 配置代理</title>
      <link href="/blog/2021/08/06/configure-agent/"/>
      <url>/blog/2021/08/06/configure-agent/</url>
      
        <content type="html"><![CDATA[<h1 id="react脚手架配置代理方法"><a href="#react脚手架配置代理方法" class="headerlink" title="react脚手架配置代理方法"></a>react脚手架配置代理方法</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><blockquote><p>在package.json中追加如下配置</p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token property">"proxy"</span><span class="token operator">:</span><span class="token string">"http://localhost:5000"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>说明：</p><ol><li>优点：配置简单，前端请求资源时可以不加任何前缀。</li><li>缺点：不能配置多个代理。</li><li>工作方式：上述方式配置代理，当请求了3000不存在的资源时，那么该请求会转发给5000 （优先匹配前端资源）</li></ol><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><ol><li><p>第一步：创建代理配置文件</p><pre class="line-numbers language-none"><code class="language-none">在src下创建配置文件：src&#x2F;setupProxy.js<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>编写setupProxy.js配置具体代理规则：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http-proxy-middleware'</span><span class="token punctuation">)</span>module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">app</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>    <span class="token function">proxy</span><span class="token punctuation">(</span><span class="token string">'/api1'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//api1是需要转发的请求(所有带有/api1前缀的请求都会转发给5000)</span>      target<span class="token operator">:</span> <span class="token string">'http://localhost:5000'</span><span class="token punctuation">,</span> <span class="token comment">//配置转发目标地址(能返回数据的服务器地址)</span>      changeOrigin<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">//控制服务器接收到的请求头中host字段的值</span>      <span class="token comment">/*      changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000      changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:3000      changeOrigin默认值为false，但我们一般将changeOrigin值设为true      */</span>      pathRewrite<span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token string">'^/api1'</span><span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">&#125;</span> <span class="token comment">//去除请求前缀，保证交给后台服务器的是正常请求地址(必须配置)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">proxy</span><span class="token punctuation">(</span><span class="token string">'/api2'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>       target<span class="token operator">:</span> <span class="token string">'http://localhost:5001'</span><span class="token punctuation">,</span>      changeOrigin<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>      pathRewrite<span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token string">'^/api2'</span><span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>说明：</p><ol><li>优点：可以配置多个代理，可以灵活的控制请求是否走代理。</li><li>缺点：配置繁琐，前端请求资源时必须加前缀。</li></ol>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>promise</title>
      <link href="/blog/2021/06/21/promise/"/>
      <url>/blog/2021/06/21/promise/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Promise"><a href="#什么是Promise" class="headerlink" title="什么是Promise"></a>什么是Promise</h1><blockquote><p>他是一个对象，是用来处理异步操作的，可以让我们写异步调用的时候写起来更加优雅，更加美观便于阅读。顾名思义为承诺、许诺的意思，意思是使用了Promise之后他肯定会给我们答复，无论成功或者失败都会给我们一个答复。Promise有三种状态：pending（进行中），resolved（完成），rejected（失败）。</p></blockquote><h2 id="怎么使用Promise"><a href="#怎么使用Promise" class="headerlink" title="怎么使用Promise"></a>怎么使用Promise</h2><ul><li><p>promise 对象和 es6 配合使用，es6中构造函数原型上有一个比较常用的 then 方法，用来执行回调函数，then 方法接受两个参数，第一个是成功的 resolved 的回调，另一个是失败 rejected 的回调，第二个失败的回调参数可选。并且 then 方法里也可以返回 promise 对象</p></li><li><p>理论已经到位，下面上代码</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token comment">// 运行结果</span><span class="token number">1</span><span class="token number">2</span><span class="token number">4</span><span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>为什么是这个结果呢？Promise 内部是顺序执行的，resolve 是异步执行的</p></li><li><p>另外 Promise.all() 也是比较常见的，什么时候使用呢？适合用于所有的结果都成功了才去执行 then（）成功的操作，废话不多说，上代码</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> p3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">,</span> p3<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">results</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我们都成功了'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>上面执行结果为 我们都成功了，那么如果有失败的呢？下面请看代码</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'我是p2我失败了'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> p3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">,</span> p3<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">results</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我们都成功了'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>就会返回 我是 p2 我失败了</p></li><li><p>接下来我们使用 promise 对象和 es6 中构造函数原型上的 finally() 配合使用，请看代码</p></li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> achievement <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">99</span><span class="token punctuation">)</span><span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>achievement <span class="token operator">></span> <span class="token number">60</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'我及格了'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'我没及格'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">pass</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>pass<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">fail</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fail<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">finally</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我考试了'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>不管考试是否及格，都会返回’我考试了’</p></li><li><p>下面讲解一下 Promise.race() 的作用也是同时执行多个实例，只要有一个实例改变状态，Promise就改为那个实例所改变的状态，通俗的说呢，就是赛跑，有一个完成，就结束了，下面直接上代码讲解</p></li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">rabbit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        <span class="token comment">//延时函数，用于给请求计时</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>            <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'我是兔子，我跑完了'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">tortoise</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>            <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'我是乌龟，我居然输了'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Promise<span class="token punctuation">.</span><span class="token function">race</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token function">rabbit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">tortoise</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>结果很明显这次兔子赢了，嘿嘿。 </li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>class 类</title>
      <link href="/blog/2021/06/04/class/"/>
      <url>/blog/2021/06/04/class/</url>
      
        <content type="html"><![CDATA[<h1 id="class类的声明及使用"><a href="#class类的声明及使用" class="headerlink" title="class类的声明及使用"></a>class类的声明及使用</h1><blockquote><p>在面向对象的编程中，class是用于创建对象的可扩展的程序代码模版，它为对象提供了状态（成员变量）的初始值和行为（成员函数或方法）的实现。</p></blockquote><h2 id="声明类的基本语法"><a href="#声明类的基本语法" class="headerlink" title="声明类的基本语法"></a>声明类的基本语法</h2><ol><li><p>正如官方所说 ES6 的类，完全可以看作构造函数的另一种写法。</p></li><li><p>类的内部必须存在 constructor 函数,如果没有显式定义，一个空的 constructor 方法会被默认添加。</p></li><li><p>除了 constructor 函数之外的函数都相当于共有方法</p></li><li><p>类的内部默认只能写方法</p></li><li><p>类的原型 <strong>proto</strong> 就是他的 constructor 和他的方法</p><ul><li><p>当实例化对象访问一个属性的时候</p><ul><li>先找 constructor </li><li>在找类的原型对象</li><li>在看有没有继承，有继承的话类的实例化对象的__proto__</li><li>当找到最后一层 <strong>proto</strong> 指的就是 Object 构造函数的原型 在往上就是 null<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">class Point&#123;    constructor(x,y)&#123;        this.x=x        this.y=y    &#125;    tostring()&#123;        return `($&#123;this.x&#125;,$&#123;this.y&#125;)`    &#125;&#125;let p =new Point(1,2)console.log(p)console.log(p.toString())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>Point 类除了构造方法，还定义了一个toString()方法。注意，定义toString()方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法与方法之间不需要逗号分隔，加了会报错。</p></li></ul></li><li><p>constructor 方法默认返回实例对象（即this）也可以返回其他对象即在 constructor 内 return 一个对象</p> <pre class="line-numbers language-javaScript" data-language="javaScript"><code class="language-javaScript">class Foo &#123;    constructor() &#123;        return Object.create(null);    &#125;&#125;const foo &#x3D; new Foo()console.log(foo);&#x2F;&#x2F;No properties<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="class和自定义类型的区别"><a href="#class和自定义类型的区别" class="headerlink" title="class和自定义类型的区别"></a>class和自定义类型的区别</h2><ul><li>class的声明不会提升，与let类似</li><li>class的声明自动运行于严格模式之下</li><li>class声明的方法不可枚举（显著区别）</li><li>class的内部方法没有[[construct]]属性，无法new</li><li>调用class的构造函数必须new</li><li>class内部方法不能同名</li></ul><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ol><li>class的声明自动运行于严格模式之下</li><li>class的声明不会提升，与let类似</li><li>name属性总是返回紧跟在class关键字后面的类名 <pre class="line-numbers language-javaScript" data-language="javaScript"><code class="language-javaScript">class Point &#123;&#125;Point.name &#x2F;&#x2F; &quot;Point&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>this 的指向<ul><li>类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</li></ul></li></ol><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><ul><li><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，但是可以被类继承，而是直接通过类来调用，这就称为“静态方法”</p><pre class="line-numbers language-javaScript" data-language="javaScript"><code class="language-javaScript">class Foo &#123;static classMethod() &#123;    return &#39;hello&#39;;&#125;&#125;console.log(Foo.classMethod()); &#x2F;&#x2F; &#39;hello&#39;var foo &#x3D; new Foo();console.log(foo.classMethod());&#x2F;&#x2F;会报错，无法调用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Foo类的classMethod方法前有static关键字，表明该方法是一个静态方法，可以直接在Foo类上调用（Foo.classMethod()），而不是在Foo类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。</p></li><li><p>父类的静态方法，可以被子类继承。</p><pre class="line-numbers language-javaScript" data-language="javaScript"><code class="language-javaScript">class Foo &#123;static classMethod() &#123;    return &#39;hello&#39;;&#125;&#125;class Bar extends Foo &#123;&#125;Bar.classMethod() &#x2F;&#x2F; &#39;hello&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2></li><li><p>优点</p><ul><li>减少代码冗余 父类可以为子类提供通用的属性，而不必因为增加功能，而逐个修改子类的属性</li><li>代码复用 同上</li><li>代码易于管理和扩展 子类在父类基础上，可以实现自己的独特功能</li></ul></li><li><p>缺点</p><ul><li>耦合度高 如果修改父类代码，将影响所有继承于它的子类</li><li>影响性能 子类继承于父类的数据成员，有些是没有使用价值的。但是，在实例化的时候，已经分配了内存。所以，在一定程度上影响程序性能。</li></ul></li><li><p>可以扩充  增加新的方法 属性等</p></li><li><p>子class中如果父class有constructor必须用super方法调用父class类</p>  <pre class="line-numbers language-javaScript" data-language="javaScript"><code class="language-javaScript">class Point &#123;    constructor(x, y) &#123;        this.x &#x3D; x        this.y &#x3D; y    &#125;    tostring() &#123;        return &#96;我的坐标为($&#123;this.x&#125;,$&#123;this.y&#125;)&#96;    &#125;&#125;class ColorPoint extends Point &#123;    constructor(x, y, color) &#123;        super(x, y)        this.color &#x3D; color    &#125;    say() &#123;        return &#96;I&#39;m $&#123;this.color&#125;&#96;    &#125;&#125;let colorP &#x3D; new ColorPoint(1, 1, &quot;red&quot;)console.log(colorP.tostring());console.log(colorP.say());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构造函数</title>
      <link href="/blog/2021/06/04/constructors/"/>
      <url>/blog/2021/06/04/constructors/</url>
      
        <content type="html"><![CDATA[<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><blockquote><p>面向对象编程(OOP)：具有灵活性，代码可复用性，高度模块化等特点。 1.对象是单个实物的抽象。 2.对象是一个容器，封装了对应属性和方法。 属性是对象的状态，方法是对象的行为。</p></blockquote><h2 id="什么是构造函数？"><a href="#什么是构造函数？" class="headerlink" title="什么是构造函数？"></a>什么是构造函数？</h2><ul><li>依然是个函数，函数名首字母必须大写</li><li>构造函数内部使用 this 指向创建好的对象内添加属性或方法</li><li>必须有 new 不然 this 指向的会变成 windows</li><li>构造函数永远一个原型属性 prototype ，该属性是一个对象 这个对象内创建的内容是给所有创建的对象添加一个属性</li><li>只要是对象内部都会默认有一个__proto__属性，如果这个对象是你的某个构造函数创建出来的话，那么这个__proto__指的就是你的构造西数的原型对象,如果不是那么这个__proto__指的就是js内置的构造函数 Object 的原型对象,如果一个对象一直查找__proto__那么最终指向的是null</li><li>原型内的属性和方法(prototype声明的方法)会在实例化对象下的__proto__属性内显示(该属性指的是创建该实例化对象的构造函数的原型对象)；</li><li>如果原型对象(prototype)修改了公共的原型对象方法也改变了</li><li>构造函数的原型对象内默认会有一个 constructor 方法，该方法指的是构造函数本身  <pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">function CreatCat(name, age) &#123;    this.name = name;    this.age = age;&#125;CreatCat.prototype.say = function () &#123;    console.log(this.name)&#125;var cat1 = new CreatCat("咪咪", 1)console.log(cat1.constructor);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>当实例化对象访问或者获取 公共的原型内的方法或者属性的时候  一直会在原型对象内查找  如果原型对象修改了，实例化对象的公共属性和方法也变了(上面的say方法)<h2 id="构造函数的合并"><a href="#构造函数的合并" class="headerlink" title="构造函数的合并"></a>构造函数的合并</h2></li></ul><ul><li>普通合并，用 assign 将 user 的方法也合并给 systemuser，但不会改变 systemuser 的原型对象  <pre class="line-numbers language-javaScript" data-language="javaScript"><code class="language-javaScript">function User(name, age) &#123;    this.name &#x3D; name;    this.age &#x3D; age;&#125;User.prototype.say &#x3D; function () &#123;    console.log(&quot;猫&quot;)&#125;var user1 &#x3D; new User(&quot;张三&quot;, 18)console.log(user1);function SystemUser(username, userage) &#123;    User.call(this, username, userage);&#125;Object.assign(SystemUser.prototype, User.prototype);var systemuser1 &#x3D; new SystemUser(&quot;李四&quot;, 23)console.log(systemuser1);SystemUser.prototype.sayHi &#x3D; function () &#123;    console.log(&#39;我是管理员&#39;)&#125;systemuser1.sayHi();user1.sayHi();&#x2F;&#x2F;提示错误<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>另一种合并  <pre class="line-numbers language-javaScript" data-language="javaScript"><code class="language-javaScript">function Animal(type) &#123;    this.type &#x3D; type;&#125;Animal.prototype.say &#x3D; function () &#123;    console.log(&quot;我是&quot; + this.type + &quot;动物&quot;);&#125;var catAnimal &#x3D; new Animal(&quot;猫科类&quot;);console.log(catAnimal);catAnimal.say();function Cat(name, age) &#123;    this.name &#x3D; name    this.age &#x3D; age&#125;Cat.prototype &#x3D; catAnimalvar mimi &#x3D; new Cat(&#39;小花儿&#39;, 2)mimi.say()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渲染函数 &amp; jsx</title>
      <link href="/blog/2021/06/01/render/"/>
      <url>/blog/2021/06/01/render/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍渲染函数（render）"><a href="#介绍渲染函数（render）" class="headerlink" title="介绍渲染函数（render）"></a>介绍渲染函数（render）</h2><blockquote><p>render 在 vue 中也是比较常用的一个方法</p></blockquote><ul><li><p>在 vue 中我们使用模板 HTML 语法组建页面的，使用 render 函数我们可以用 js 语言来构建 DOM。</p></li><li><p>因为 vue 是虚拟 DOM ，所以在拿到 template 模板时也要转译成 VNode 的函数，而用 render 函数构建 DOM ， vue 就免去了转译的过程，也就是如果使用渲染函数 render 时需要将 template 部分删除，因为 render 函数，可以帮我们创建 template。</p></li><li><p>当使用 render 函数描述虚拟 DOM 时， vue 提供一个函数，这个函数是就构建虚拟 DOM 所需要的工具。官网上给他起了个名字叫 createElement。一般简写为 h。</p></li></ul><h2 id="使用渲染函数（render）"><a href="#使用渲染函数（render）" class="headerlink" title="使用渲染函数（render）"></a>使用渲染函数（render）</h2><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">render(createElement)&#123;    return createElement(    // &#123;String | Object | Function&#125;    // 一个 HTML 标签字符串，组件选项对象，或者解析上述任何一种的一个 async 异步函数，必要参数。    // 可以写成字符串拼接的标签名    'div',    // &#123;Object&#125;    // 一个包含模板相关属性的数据对象这样，您可以在 template 中使用这些属性。可选参数。    // 该对象内可以设置 class style 事件绑定prop插槽...    &#123;        // (详情见下一节)    &#125;,    // &#123;String | Array&#125;    // 子节点 (VNodes)，由 `createElement()` 构建而成，    // 或使用字符串来生成“文本节点”。可选参数。    [        '先写一些文字',        createElement('h1', '一则头条'),        createElement(MyComponent, &#123;            props: &#123;                someProp: 'foobar'            &#125;        &#125;)    ]    )&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="举例渲染函数（render）"><a href="#举例渲染函数（render）" class="headerlink" title="举例渲染函数（render）"></a>举例渲染函数（render）</h2><ul><li>为什么使用 render 函数？</li><li>什么情况下使用 render 函数？</li><li>创建一个等级标题组件 根据不同的 level 创建不同的 标题  <pre class="line-numbers language-javaScript" data-language="javaScript"><code class="language-javaScript">&#x2F;&#x2F; 如果不使用 render 使用 插槽&lt;template&gt;&lt;h1 v-if&#x3D;&quot;Level &#x3D;&#x3D;&#x3D; 1&quot;&gt;    &lt;slot &#x2F;&gt;&lt;&#x2F;h1&gt;&lt;h2 v-else-if&#x3D;&quot;Level &#x3D;&#x3D;&#x3D; 2&quot;&gt;    &lt;slot &#x2F;&gt;&lt;&#x2F;h2&gt;&lt;h3 v-else-if&#x3D;&quot;Level &#x3D;&#x3D;&#x3D; 3&quot;&gt;    &lt;slot &#x2F;&gt;&lt;&#x2F;h3&gt;&lt;&#x2F;template&gt;export default &#123;    props: [&quot;Level&quot;],&#125;;&lt;&#x2F;script&gt;&#x2F;&#x2F; 这里用模板并不是最好的选择：不但代码冗长，而且在每一个级别的标题中重复书写了 &lt;slot&gt;&lt;&#x2F;slot&gt;，在要插入锚点元素时还要再次重复。虽然模板在大多数组件中都非常好用，但是显然在这里它就不合适了。那么，我们来尝试使用 render 函数重写上面的例子<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>如果使用 render 函数  <pre class="line-numbers language-javaScript" data-language="javaScript"><code class="language-javaScript">export default &#123;    props: [&quot;Level&quot;],    render() &#123;        const tag &#x3D; &quot;h&quot; + this.Level;        return &lt;tag&gt;&#123;this.$slots.default&#125;&lt;&#x2F;tag&gt;;    &#125;,&#125;;&lt;&#x2F;script&gt;&#x2F;&#x2F; 看起来简单多了！这样代码精简很多，但是需要非常熟悉 Vue 的实例 property。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>水平垂直居中</title>
      <link href="/blog/2021/05/25/center/"/>
      <url>/blog/2021/05/25/center/</url>
      
        <content type="html"><![CDATA[<h1 id="实现水平垂直居中"><a href="#实现水平垂直居中" class="headerlink" title="实现水平垂直居中"></a>实现水平垂直居中</h1><blockquote><p>我们在日常的开发中，经常会遇到这样一个问题，就是如何实现居中水平垂直居中对齐。并且在面试中也会出现这样的问题，但是我们往往回答的不是很全部，而导致没有得到面试加分。接下来我们通过不同的方式来实现，让我们成功破解这道面试</p></blockquote><h2 id="公共代码"><a href="#公共代码" class="headerlink" title="公共代码"></a>公共代码</h2><ul><li><p>body 如下</p><pre class="line-numbers language-body" data-language="body"><code class="language-body">&lt;div class&#x3D;&quot;wrap&quot;&gt;    &lt;div class&#x3D;&quot;box&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>style 公共样式</p><pre class="line-numbers language-style" data-language="style"><code class="language-style">.wrap &#123;    width: 300px;    height: 300px;    border: 1px solid red;&#125;.box1 &#123;    width: 100px;    height: 100px;    background-color: pink;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="通过定位实现定高定宽的盒子居中"><a href="#通过定位实现定高定宽的盒子居中" class="headerlink" title="通过定位实现定高定宽的盒子居中"></a>通过定位实现定高定宽的盒子居中</h2><h3 id="通过宽度和高度"><a href="#通过宽度和高度" class="headerlink" title="通过宽度和高度"></a>通过宽度和高度</h3><ol><li>方法一<ul><li>通过定位方式，设置绝对子元素的 margin-top: -元素高度的一半px</li><li>style 样式<pre class="line-numbers language-style" data-language="style"><code class="language-style">.wrap &#123;    position: relative;&#125;.box1 &#123;    position: absolute;    top: 50%;    left: 50%;    margin-top: -50px;    margin-left: -50px;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ol><ol start="2"><li>方法二<ul><li>使用 calc() 函数对数值属性执行减法运算</li><li>css 样式如下<pre class="line-numbers language-style" data-language="style"><code class="language-style">.wrap &#123;    position: relative;&#125;.box1 &#123;    position: absolute;    top: calc(50% - 50px);    left: calc(50% - 50px);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ol><h3 id="不通过宽度和高度"><a href="#不通过宽度和高度" class="headerlink" title="不通过宽度和高度"></a>不通过宽度和高度</h3><ol><li><p>方法一</p><ul><li>使用 margin 居中</li><li>css 样式如下<pre class="line-numbers language-style" data-language="style"><code class="language-style">.wrap &#123;    position: relative;&#125;.box1 &#123;    position: absolute;    top: 0;    left: 0;    bottom: 0;    right: 0;    margin: auto;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>方法二</p><ul><li>使用 translate 居中</li><li>css 样式如下<pre class="line-numbers language-style" data-language="style"><code class="language-style">.wrap &#123;    position: relative;&#125;.box1 &#123;    position: absolute;    top: 50%;    left: 50%;    transform: translate(-50%, -50%);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ol><h2 id="通过-flex-布局方式"><a href="#通过-flex-布局方式" class="headerlink" title="通过 flex 布局方式"></a>通过 flex 布局方式</h2><ul><li>css 样式如下<pre class="line-numbers language-style" data-language="style"><code class="language-style">.wrap &#123;    display: flex;    justify-content: center;    align-items: center&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据的深浅拷贝</title>
      <link href="/blog/2021/05/24/copy/"/>
      <url>/blog/2021/05/24/copy/</url>
      
        <content type="html"><![CDATA[<h1 id="数据的深浅拷贝"><a href="#数据的深浅拷贝" class="headerlink" title="数据的深浅拷贝"></a>数据的深浅拷贝</h1><blockquote><p>在 javascript 中有不同的方法来复制对象，如果你还不熟悉这门语言的话，复制对象时就会很容易掉进陷阱里，那么我们怎样才能正确地复制一个对象呢？</p></blockquote><h2 id="先熟悉一下数据的类型"><a href="#先熟悉一下数据的类型" class="headerlink" title="先熟悉一下数据的类型"></a>先熟悉一下数据的类型</h2><ul><li><p>数据类型可分为两种：</p><ul><li>基本类型：undefined,null,Boolean,String,Number,Symbol</li><li>引用类型：Object,Array,Date,Function,RegExp等</li></ul></li><li><p>不同类型的存储方式</p><ul><li>基本类型：基本类型值在内存中占据固定大小，保存在内存中，可以说不存在深浅拷贝问题</li><li>引用类型：引用类型的值是对象，保存在内存中，而内存存储的是对象的变量标识符以及对象在内存中的存储地址，可以说引用类型给变量的是一个地址，存在深浅拷贝问题</li></ul></li><li><p>引用类型的复制方式</p><ul><li>从一个变量向另一个新变量复制引用类型的值，其实复制的是指针，最终两个变量最终都指向同一个对象</li></ul></li></ul><h2 id="认识深拷贝和浅拷贝"><a href="#认识深拷贝和浅拷贝" class="headerlink" title="认识深拷贝和浅拷贝"></a>认识深拷贝和浅拷贝</h2><ul><li><p>浅拷贝：仅仅是复制了引用地址，彼此之间的操作会互相影响</p></li><li><p>深拷贝：重新分配内存，不同的地址，相同的值，互不影响</p></li></ul><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><ol><li><p>使用 es6 的展开运算符实现</p> <pre class="line-numbers language-javaScript" data-language="javaScript"><code class="language-javaScript">let obj &#x3D; &#123; name: &#39;小明&#39;, age: 18 &#125;let obj1 &#x3D; &#123; ...obj &#125;obj.age &#x3D; 16console.log(obj) &#x2F;&#x2F; 16console.log(obj1) &#x2F;&#x2F; 18<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>使用 assign 方法实现浅拷贝</p> <pre class="line-numbers language-javaScript" data-language="javaScript"><code class="language-javaScript">var obj1 &#x3D; &#123; name: &#39;小明&#39; &#125;;var obj2 &#x3D; Object.assign(&#123;&#125;, obj1);obj2.name &#x3D; &#39;小张&#39;;console.log(obj1.name); &#x2F;&#x2F;小明console.log(obj2.name); &#x2F;&#x2F;小张<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>使用 slice 方法实现</p><pre class="line-numbers language-javaScript" data-language="javaScript"><code class="language-javaScript">let arr1 &#x3D; [    &#39;小明&#39;,    &#123;        age: 18    &#125;];let arr2 &#x3D; arr1.slice(0);arr2[1].age &#x3D; 20;&#x2F;** 因为数组的第一层有引用类型，浅拷贝无法实现 *&#x2F;console.log(arr1); &#x2F;&#x2F; [&quot;小明&quot;, &#123;age: 20&#125;]console.log(arr2); &#x2F;&#x2F; [&quot;小明&quot;, &#123;age: 20&#125;]arr2[0] &#x3D; &#39;小张&#39;;console.log(arr1); &#x2F;&#x2F; [&quot;小明&quot;, &#123;age: 20&#125;]console.log(arr2); &#x2F;&#x2F; [&quot;小张&quot;, &#123;age: 20&#125;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>使用 concat 方法</p><pre class="line-numbers language-javaScript" data-language="javaScript"><code class="language-javaScript">let arr1 &#x3D; [    &#39;小明&#39;,    &#123;        age: 18    &#125;];let arr2 &#x3D; [].concat(arr1);arr2[1].age &#x3D; 20;&#x2F;** 因为数组的第一层有引用类型，浅拷贝无法实现 *&#x2F;console.log(arr1); &#x2F;&#x2F; [&quot;小明&quot;, &#123;age: 20&#125;]console.log(arr2); &#x2F;&#x2F; [&quot;小明&quot;, &#123;age: 20&#125;]arr2[0] &#x3D; &#39;小张&#39;;console.log(arr1); &#x2F;&#x2F; [&quot;小明&quot;, &#123;age: 20&#125;]console.log(arr2); &#x2F;&#x2F; [&quot;小张&quot;, &#123;age: 20&#125;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ul><li>Array的slice和concat方法并不是真正的深拷贝，对于Array的第一层的元素是深拷贝，而Array的第二层 slice和concat方法是复制引用。所以，Array的slice和concat方法都是浅拷贝。</li></ul><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><ol><li>通过递归实现深拷贝</li></ol><pre class="line-numbers language-javaScript" data-language="javaScript"><code class="language-javaScript">var post &#x3D; &#123;    title: &quot;vue 从入门到精通&quot;,    data: &quot;2020-12-20&quot;,    author: &#123;        name: &quot;wao&quot;,        avatar_url: &quot;http:&#x2F;&#x2F;xxx.jpg&quot;    &#125;,    comment: [&quot;666&quot;, &quot;真棒&quot;, [1, 2, 3]]&#125;&#x2F;&#x2F; 值 instanceof Array 判断是否是由构造函数Array构成的   一般用于检测 Array   RegExp    Object   Functionfunction deepCopy(obj) &#123;    var newObj &#x3D; obj instanceof Array ? [] : &#123;&#125;;    &#x2F;&#x2F; 也可以使用 var newObj &#x3D; Array.isArray(obj) ? [] : &#123;&#125;;    for (var key in obj) &#123;        var val &#x3D; obj[key];        if (typeof val &#x3D;&#x3D;&#x3D; &quot;object&quot;) &#123;            newObj[key] &#x3D; deepCopy(val);        &#125; else &#123;            newObj[key] &#x3D; val;        &#125;    &#125;    return newObj;&#125;var poster &#x3D; deepCopy(post);poster.data &#x3D; &quot;2020-12-12&quot;;poster.author.name &#x3D; &quot;liu&quot;;poster.comment[0] &#x3D; &quot;很6&quot;;poster.comment[2][0] &#x3D; 0;console.log(post);console.log(poster);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防抖和节流</title>
      <link href="/blog/2021/05/24/debounce-throttling/"/>
      <url>/blog/2021/05/24/debounce-throttling/</url>
      
        <content type="html"><![CDATA[<h2 id="认识防抖和节流"><a href="#认识防抖和节流" class="headerlink" title="认识防抖和节流"></a>认识防抖和节流</h2><blockquote><p>在前端开发的过程中，我们经常会需要绑定一些持续触发的事件，如 resize、scroll、mousemove 等等，但有些时候我们并不希望在事件持续触发的过程中那么频繁地去执行函数，那要怎么办呢？</p></blockquote><ol><li><p>什么是防抖？</p><ul><li>假设现在坐公交车，很多人不断在刷卡，那么此时司机是不能开车的，等到乘客都刷卡完毕了，司机需要等待一会儿（延迟时间）确认乘客都做好之后准备开车，此时正好又有一个乘客上车，那么司机又要重新等待刷卡上人再次坐稳之后再开车。</li></ul></li><li><p>什么是节流？</p><ul><li>保证如果电梯第一个人进来后，10秒后准时运送一次，这个时间从第一个人上电梯开始计时，不等待，如果没有人，则不运行。</li></ul></li></ol><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><ul><li>具体代码如下 如果一直滚动滚动条不会运行函数，如果停止滚动一秒后就会运行一次函数  <pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">function debounce(fn, delay) &#123;    let timer = null //借助闭包，前面讲解过闭包    return function () &#123;        if (timer) &#123;            clearTimeout(timer)        &#125;        timer = setTimeout(fn, delay) // 简化写法    &#125;&#125;function showTop() &#123;    var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;    console.log('滚动条位置：' + scrollTop);&#125;window.addEventListener("scroll", debounce(showTop, 1000))// 为了方便观察效果我们取个大点的间断值，实际使用根据需要来配置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><ul><li>第一种写法，没有定义函数，每隔一秒输出一次滚动条位置<pre class="line-numbers language-javaScript" data-language="javaScript"><code class="language-javaScript">var lastTime &#x3D; 0;document.addEventListener(&quot;scroll&quot;, function (event) &#123;    var currentTime &#x3D; event.timeStamp;    if (currentTime - lastTime &gt; 500) &#123;        var scrollTop &#x3D; document.body.scrollTop || document.documentElement.scrollTop;        console.log(&#39;滚动条位置：&#39; + scrollTop);        lastTime &#x3D; currentTime;    &#125;&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ul><li>但是我们一般都会定义一个函数，不会直接写成节流，函数写法一如下<pre class="line-numbers language-javaScript" data-language="javaScript"><code class="language-javaScript">function throttle(fn, delay) &#123;    let valid &#x3D; true    return function () &#123;        if (!valid) &#123;            &#x2F;&#x2F;休息时间 暂不执行            return false        &#125;        &#x2F;&#x2F; 工作时间，执行函数并且在间隔期内把状态位设为无效        valid &#x3D; false        setTimeout(() &#x3D;&gt; &#123;            fn()            valid &#x3D; true;        &#125;, delay)    &#125;&#125;&#x2F;&#x2F; 也可以直接将setTimeout的返回的标记当做判断条件-判断当前定时器是否存在，如果存在表示还在冷却，并且在执行fn之后消除定时器表示激活，原理都一样function showTop() &#123;    var scrollTop &#x3D; document.body.scrollTop || document.documentElement.scrollTop;    console.log(&#39;滚动条位置：&#39; + scrollTop);&#125;window.onscroll &#x3D; throttle(showTop, 1000);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ul><li>节流函数并不止上面这种实现方案,例如可以完全不借助setTimeout，可以把状态位换成时间戳，然后利用时间戳差值是否大于指定间隔时间来做判定。具体函数如下<pre class="line-numbers language-javaScript" data-language="javaScript"><code class="language-javaScript">function throttle(fn, delay) &#123;    var lastTime &#x3D; 0;    return function () &#123;        that &#x3D; this;        arg &#x3D; arguments;        nowTime &#x3D; Date.now();        if (lastTime &#x3D;&#x3D;&#x3D; 0 || nowTime - lastTime &gt;&#x3D; delay) &#123;            lastTime &#x3D; Date.now();            fn.apply(that, arg);            &#x2F;&#x2F; 有这句话就可以传递showTop的所以值，可以返回event的一些数据，和this的数据        &#125;    &#125;&#125;function showTop() &#123;    var scrollTop &#x3D; document.body.scrollTop || document.documentElement.scrollTop;    console.log(&#39;滚动条位置：&#39; + scrollTop);&#125;window.onscroll &#x3D; throttle(showTop, 1000);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ul><li>好啦，关于防抖和节流就到这里了，只要动手写一写，相信你很快就会掌握</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闭包</title>
      <link href="/blog/2021/05/19/closure/"/>
      <url>/blog/2021/05/19/closure/</url>
      
        <content type="html"><![CDATA[<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><blockquote><p>几乎所有语言的最基础模型之一就是在变量中存储值，并且在稍后取出或修改这些值。在变量中存储值和取出值的能力，给程序赋予了状态。这就引伸出两个问题：这些变量被存储在哪里？程序如何在需要的时候找到它们？回答这些问题需要一组明确定义的规则，它定义了如何存储变量，以及如何找到这些变量。我们称这组规则为：作用域。</p></blockquote><h2 id="闭包的产生和特点"><a href="#闭包的产生和特点" class="headerlink" title="闭包的产生和特点"></a>闭包的产生和特点</h2><ol><li>简单的说函数嵌套函数，就会产生闭包</li><li>作用域的嵌套 而且嵌套关系永远存在</li><li>闭包外层定义的变量会一直存储在内存中，等待闭包内层的作用域访问</li><li>内存占用比较大</li></ol><h2 id="为什么使用闭包"><a href="#为什么使用闭包" class="headerlink" title="为什么使用闭包"></a>为什么使用闭包</h2><ol><li>这就要从变量作用域开始说了<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> a<span class="token operator">=</span><span class="token number">666</span><span class="token punctuation">;</span>　　<span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>　　　　<span class="token function">alert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>　　<span class="token punctuation">&#125;</span>　　<span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 666</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ol start="2"><li>我们函数外部定义的变量函数内部是可以拿到的但是，如果是函数内部定义的变量呢<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>　　　　<span class="token keyword">var</span> a<span class="token operator">=</span><span class="token number">666</span><span class="token punctuation">;</span>　　<span class="token punctuation">&#125;</span>　　<span class="token function">alert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//a is not defined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ol start="3"><li>这样就会报错，那我我们如果需要用的函数内部的变量呢？于是闭包就产生了</li></ol><h2 id="讲解闭包"><a href="#讲解闭包" class="headerlink" title="讲解闭包"></a>讲解闭包</h2><ol><li><p>一个小栗子</p><pre class="line-numbers language-javaScript" data-language="javaScript"><code class="language-javaScript">function fun()&#123;    var num &#x3D; 10;    function fun1()&#123;        num++;        console.log(num)    &#125;    return fun1;&#125;var newFun&#x3D;fun();newfun(); &#x2F;&#x2F; 11newfun(); &#x2F;&#x2F; 12newfun(); &#x2F;&#x2F; 13fun&#x3D;null;newFun&#x3D;null;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>一个小应用</p><ul><li>当前页面有5个button，要求是点击每个button的时候弹出对应的编号  <pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span>Button0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span>Button1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span>Button2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span>Button3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span>Button4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span>let btnList=document.querySelectorAll('button')for (var i = 0; i &lt; btnList.length; i++) &#123;    //使用立刻执行函数 闭包接收i的值 因为异步执行方法会在同步执行方法后执行    (function (i) &#123;        btnList[i].onclick = function () &#123;            console.log(i)        &#125;    &#125;)(i);&#125;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ol><h2 id="使用闭包的注意点"><a href="#使用闭包的注意点" class="headerlink" title="使用闭包的注意点"></a>使用闭包的注意点</h2><ol><li>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</li><li>闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>antdVue中表格操作</title>
      <link href="/blog/2021/05/15/antdvertable/"/>
      <url>/blog/2021/05/15/antdvertable/</url>
      
        <content type="html"><![CDATA[<h2 id="table-行添加事件"><a href="#table-行添加事件" class="headerlink" title="table 行添加事件"></a>table 行添加事件</h2><h3 id="在-table-标签部分添加-customRow-”Rowclick”"><a href="#在-table-标签部分添加-customRow-”Rowclick”" class="headerlink" title="在 table 标签部分添加 :customRow=”Rowclick”"></a>在 table 标签部分添加 :customRow=”Rowclick”</h3><blockquote><p>Rowclick 为绑定的事件</p></blockquote><h3 id="methord-部分如下"><a href="#methord-部分如下" class="headerlink" title="methord 部分如下"></a>methord 部分如下</h3><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token function">Rowclick</span> <span class="token punctuation">(</span><span class="token parameter">record<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// record 为这一行的值，index为索引值</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>      on<span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token function-variable function">click</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token function-variable function">dblclick</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器存储</title>
      <link href="/blog/2021/05/15/browser-storage/"/>
      <url>/blog/2021/05/15/browser-storage/</url>
      
        <content type="html"><![CDATA[<h2 id="在浏览器存储数据"><a href="#在浏览器存储数据" class="headerlink" title="在浏览器存储数据"></a>在浏览器存储数据</h2><blockquote><p>日常开发中,难免会遇到一些要求浏览器储存一些数据的需求.目前常用的储存方法有:</p></blockquote><ol><li><p>localStorage</p><ul><li>生命周期是永久的，这意味着除非用户显示在浏览器提供的UI上清除 localStorage 数据，否则这些数据将永远存在。</li></ul></li><li><p>sessionStorage</p><ul><li>生命周期为当前窗口或标签页，一旦窗口或标签页被永久关闭了，那么所有通过 sessionStorage 存储的数据也就被清空了。</li></ul></li></ol><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol><li>存储数据<ul><li>sessionStorage.setItem(‘name’,value)</li><li>localStorage.setItem(‘name’,value)</li></ul></li></ol><ol start="2"><li><p>获取数据</p><ul><li>let array = sessionStorage.valueOf() //获取全部数据</li><li>sessionStorage.getItem(‘name’) //获取指定name的值</li><li>localStorage 用法相同</li></ul></li></ol><ol start="3"><li>删除数据<ul><li>sessionStorage.removeItem(‘name’) //删除指定名字的数据</li><li>sessionStorage.clear() //清楚所有 sessionStorage 信息</li></ul></li><li>共享数据<ul><li>不同浏览器无法共享 localStorage 或 sessionStorage 中的信息。相同浏览器的不同页面间可以共享相同的 localStorage（页面属于相同域名和端口），但是不同页面或标签页间无法共享 sessionStorage 的信息。这里需要注意的是，页面及标 签页仅指顶级窗口，如果一个标签页包含多个 iframe 标签且他们属于同源页面，那么他们之间是可以共享 sessionStorage 的。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="/blog/about/index.html"/>
      <url>/blog/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>404</title>
      <link href="/blog/404/index.html"/>
      <url>/blog/404/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>contact</title>
      <link href="/blog/contact/index.html"/>
      <url>/blog/contact/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>friends</title>
      <link href="/blog/friends/index.html"/>
      <url>/blog/friends/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/blog/categories/index.html"/>
      <url>/blog/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/blog/tags/index.html"/>
      <url>/blog/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
